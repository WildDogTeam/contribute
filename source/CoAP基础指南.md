<link rel="stylesheet" href="http://yandex.st/highlightjs/6.2/styles/googlecode.min.css">
 
<script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
<script src="http://yandex.st/highlightjs/6.2/highlight.min.js"></script>
 
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
 $(document).ready(function(){
      $("h2,h3,h4,h5,h6").each(function(i,item){
        var tag = $(item).get(0).localName;
        $(item).attr("id","wow"+i);
        $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
        $(".newh2").css("margin-left",0);
        $(".newh3").css("margin-left",20);
        $(".newh4").css("margin-left",40);
        $(".newh5").css("margin-left",60);
        $(".newh6").css("margin-left",80);
      });
 });
</script>
<div id="category"></div>
##2, 受限应用协议CoAP
CoAP协议的交互模型与HTTP的客户端/服务端模型类似。然而，在M2M的交互场景中，一个使用CoAP协议的设备通常既是客户端又是服务端。CoAP中的请求与HTTP协议中的请求相同，是由客户端发起的，请求一个位于服务端的资源（用URI标识），执行一个动作（用Method Code标识）。然后服务端发回一个响应，带有一个响应代码（Response Code），这个响应中有可能也包含一个资源的表现（附带响应格式）。

与HTTP协议不同的是，CoAP的交互是异步的，构建于面向数据报的传输协议，如UDP。交互是通过一个消息层来实现的，消息层提供了可选的可靠性支持（采用指数回退）。CoAP协议中定义了四种类型的消息：
CON, NON, ACK和RST。这四种类型的消息中包含有请求和响应标识码，标识着这些消息是请求还是响应。请求可以包含在CON和NON两种类型中，而响应则除了可以包含在CON和NON之中，还可以包含在附带响应的ACK中。

从逻辑上，可以把CoAP协议划分为两层：消息层，用于处理UDP数据包和异步；请求/响应层，使用Method和Response Code，具体见图1。当然，CoAP是一个协议，消息和请求/响应仅仅是其头部特性。

			+----------------------+
			|      Application     |
			+----------------------+
			+----------------------+  \
			|  Requests/Responses  |  |
			|----------------------|  | CoAP
			|       Messages       |  |
			+----------------------+  /
			+----------------------+
			|          UDP         |
			+----------------------+

			图1 CoAP中的抽象层次
###2.1, 消息模型
CoAP的消息模型是建立在UDP端到端通信的基础上的。

CoAP的头部为固定长度的（4个字节）二进制格式，其后是紧凑的二进制格式的选项部分，然后是数据部分(payload)，请求和响应都采用这种格式。CoAP的消息格式在第3章中详细讲述。每个消息都包含一个消息ID，用于检测重复提供传输可靠性。（这个消息ID是连续的，包含有16位，在默认的协议参数配置下，它允许每秒钟从一端到另一端传输大约250条消息）。

通过把消息标记为CON的，可以保障消息传输的可靠性。如图2所示，在收到一个CON消息之后，接收端会发送一个带有相同消息ID(Message ID)（在这个例子中是0x7d34）的ACK。如果在默认的超时时间之后没有收到带有相同消息ID的ACK，那么它将会被重传，如果仍然没有收到ACK，此后重传超时时间会以指数级递增。当接收端无法处理一个CON消息(也无法返回一个正常的错误响应)时，它将会回应一个RST消息，而不是ACK。

                        Client              Server
                           |                  |
                           |   CON [0x7d34]   |
                           +----------------->|
                           |                  |
                           |   ACK [0x7d34]   |
                           |<-----------------+
                           |                  |

                  	   图2 可靠消息传输

当消息不需要可靠传输（例如持续不断的读取一个传感器数据）时，可以发送NON的消息。如图3所示，这些消息不需要应答，但它们仍然拥有消息ID，用于检测重复（在这个例子中0x01a0）。当接收端无法处理一个NON消息时，它有可能会返回一个RST消息。

                        Client              Server
                           |                  |
                           |   NON [0x01a0]   |
                           +----------------->|
                           |                  |

                 	   图3 非可靠消息传输

第4章详细讲述了CoAP消息的细节。

由于CoAP运行在UDP之上，它也支持目的ip为多播地址，可以实现多播CoAP请求。第8章讲述了正确的使用多播地址发送CoAP消息，和避免由此造成响应拥塞的预防措施。

第9章定义了CoAP的几个安全模型，从无安全的，到基于证书的安全机制。在本文档中，只指定DTLS作为协议的安全基础。文档[[IPsec-CoAP]](www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22Using+CoAP+with+IPsec%22)对在CoAP中使用IPsec进行了讨论。

###2.2, 请求/响应模型
CoAP的请求和响应的语义都包含在CoAP消息中，请求和响应的消息分别带有方法码（Method Code）和响应码（Response Code）。可选的或者是默认的请求和响应信息，例如URI和数据的媒体类型等，都做为协议中的选项部分。CoAP使用一个Token来匹配请求对应的响应（见5.3节）。注意，这个Token和消息ID不同。

请求消息分为CON和NON两种。对于CON类型的请求，如果响应数据可以立即生成，那么对于请求消息的ACK就会同时携带响应数据。这就是附带响应，在5.2.1节中详细讲述。（不需要对附带响应再进行单独的应答，因为假如携带响应数据的ACK丢失，那么客户端会重传请求消息）。图4中展示了对于两个GET请求，服务端返回附带响应的例子，一个成功，一个导致了4.04（资源未找到）响应。
 
        Client              Server       Client              Server
           |                  |             |                  |
           |   CON [0xbc90]   |             |   CON [0xbc91]   |
           | GET /temperature |             | GET /temperature |
           |   (Token 0x71)   |             |   (Token 0x72)   |
           +----------------->|             +----------------->|
           |                  |             |                  |
           |   ACK [0xbc90]   |             |   ACK [0xbc91]   |
           |   2.05 Content   |             |  4.04 Not Found  |
           |   (Token 0x71)   |             |   (Token 0x72)   |
           |     "22.5 C"     |             |   "Not found"    |
           |<-----------------+             |<-----------------+
           |                  |             |                  |

           		图4 对两个GET请求的附带响应

如果请求消息是一个CON类型的，而服务端无法立即响应，那么它就会立即发回一个空的ACK消息，以免客户端重传请求消息。当响应数据准备好了之后，服务器端就会把它组装成一个新的CON类型的消息（这需要客户端的ACK）。这种形式被称为“单独响应”，如图5所示，更多细节参见5.2.2节。
 
                        Client              Server
                           |                  |
                           |   CON [0x7a10]   |
                           | GET /temperature |
                           |   (Token 0x73)   |
                           +----------------->|
                           |                  |
                           |   ACK [0x7a10]   |
                           |<-----------------+
                           |                  |
                           ... Time Passes  ...
                           |                  |
                           |   CON [0x23bb]   |
                           |   2.05 Content   |
                           |   (Token 0x73)   |
                           |     "22.5 C"     |
                           |<-----------------+
                           |                  |
                           |   ACK [0x23bb]   |
                           +----------------->|
                           |                  |

             		   图5 GET请求和独立响应

如果一个请求是以NON类型的消息发送的，那么一般来说响应也将是一个NON类型的消息，但服务器也有可能发送一个CON类型的消息作为响应。这种交互如图6所示。

                         Client              Server
                           |                  |
                           |   NON [0x7a11]   |
                           | GET /temperature |
                           |   (Token 0x74)   |
                           +----------------->|
                           |                  |
                           |   NON [0x23bc]   |
                           |   2.05 Content   |
                           |   (Token 0x74)   |
                           |     "22.5 C"     |
                           |<-----------------+
                           |                  |

    			   图6 NON类型消息的请求和响应

类似HTTP，CoAP协议也使用GET, PUT, POST和DELETE方法，具体的语义在5.8节中讲述。（注意，CoAP协议的这些方法的语义很像HTTP，但和HTTP不完全一样。读者对于HTTP协议的经验对理解CoAP是很有帮助的，但是二者之间还是有不少的区别，值得阅读本规范）。

在特定的情况下，可以增加这四种方法之外的方法。新的方法不一定要使用成对的请求/响应的形式。即使对于现有的方法，一个请求也有可能产生多个响应，例如一个多播请求（第8章），或者一个订阅(Observe)选项。

服务端对于URI的支持是很简单的，因为客户端已经把URI拆分为主机、端口、路径和参数，并可以使用默认值。响应代码是HTTP状态代码的一个子集，但增加了几个CoAP特有的响应码，在5.9节中讲述。

###2.3, 中间人和缓存
为了能够快速的对客户端的请求进行响应，CoAP协议支持将响应缓存。通过在CoAP响应消息中的时效性和有效性信息，可以启用简单的缓存。缓存可以位于端中，也可以位于中间代理。5.6节具体描述了缓存。

代理在受限网络中十分有用，它能够有效的减少网络传输、提高性能、获取正在休眠的设备的资源，并且能提高安全性。协议支持一个CoAP端代理另一个CoAP端的请求。当使用代理时，请求信息包含了资源的URI，目标IP地址则被设置成了代理的IP地址。关于代理功能的更多信息请阅读5.7节。

由于CoAP是根据REST架构设计的，因此表现的和HTTP协议很类似，很容易做从CoAP到HTTP的映射和从HTTP到CoAP的映射。这样的映射可用于使用CoAP协议实现一个HTTP REST接口，或者在HTTP与CoAP之间互转。这个互转可以由一个跨协议代理来实现，这个代理把请求方法、返回代码、媒体类型、选项转换为对应的HTTP中的特性。第10章讲述了更多关于HTTP映射的细节。

###2.4, 资源发现
资源发现对于M2M交互来说是很重要的，因此被CoRE Link Format [[RFC6690]](http://tools.ietf.org/pdf/rfc6690 "RFC6690")所支持，如第7章所讲述。

##3, 消息格式

CoAP的消息格式是很紧凑的，默认运行在UDP上（每个CoAP消息都是UDP数据包中的数据部分）。CoAP也可以运行在DTLS协议上（见9.1节）和其它传输协议上，例如SMS，TCP或SCTP，这些不属于本文档的范畴（CoAP不支持UDP-lite[[RFC3828]](http://tools.ietf.org/pdf/rfc3828 "[RFC3828]")和UDP zero checksum[[RFC6936]](http://tools.ietf.org/pdf/rfc6936.pdf "[RFC6936]")）。

CoAP消息用二进制格式进行编码。这个消息格式以一个固定4个字节的头部开始。此后是一个长度在0到8字节之间的Token。Token值之后是0个或多个Type-Length-Value(TLV)格式的选项(Option)。之后到整个数据报的结尾都是payload部分，payload可以为空。

    |       0       |       1       |       2       |       3       |
    |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	|Ver| T |  TKL  |      Code     |          Message ID           |
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	|   Token (if any, TKL bytes) ...
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	|   Options (if any) ...
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	|1 1 1 1 1 1 1 1|    Payload (if any) ...
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                         图7 消息格式

头部字段定义如下：

*	版本号(Ver)：2-bit无符号整型，代表CoAP版本号。本文档的实现必须设置这个字段为0b01。其它的值为今后其它版本保留。对于带有未知版本号的消息，必须忽略。
	
*	类型(T)：2-bit无符号整型。代表这个消息的类型是：CON(0), NON(1), ACK(2),或RST(3)。这些消息类型的语义在第4章进行定义。

*	Token长度(TKL)：4-bit无符号整型。表示变长的Token字段(0-8字节）的长度。长度9-15是保留的，不能设置长度为9-15。如果设置了长度为9-15，必须被当作消息格式错误来处理。
	
*	代码(Code)：8-bit无符号整型。拆分为3-bit的分类信息和5-bit详细信息。写作”c.dd”。c是3-bit长，可以是一个从0到7的数字，dd是5-bit长，它一个两位的数字，从00到31。分类信息c可以代表是一个请求（0），一个成功的响应（2），一个客户端错误响应（4），或者一个服务端错误响应（5）。所有其它的值都是保留的。代码0.00是一个特殊的情况，表示一个空的消息。当消息是一个请求时，Code字段表示请求方法。当响应时，Code字段代表响应代码。Code字段所有可取的值都在CoAP代码表（12.1节）中定义了。请求和响应的语义定义在第5章。
	
*	消息ID(Message ID)：16-bit无符号整型，网络字节序。用于检测消息重复以及匹配ACK/RST类型的消息和CON/NON类型的消息。生成消息ID和匹配消息的规则在第4章中讲述。
	
头部之后是Token值，可以有0到8个字节，由Token长度字段指定。这个Token值用于将某个请求和对应的响应关联。生成Token和关联请求与响应的规则在5.3.1节讲述。

头部和Token之后，是0个或多个选项（见3.1节）。一个选项之后，有可能是消息结束，也可能是另一个选项，也可能是payload标识符和payload部分。

在头部、token和选项之后，是payload部分（可以没有payload）。如果有payload，并且长度不为0，那么payload之前有一个固定长度为一个字节的payload标识符（0xFF），它标志着选项部分的结束和payload部分的开始。payload部分从标识符之后开始，一直到这个UDP数据报结束，也就是说，payload部分的长度可以根据UDP数据报的长度计算出来。如果没有payload标识符，那么就代表这是一个0长度的payload。如果存在payload标识符但其后跟随的是0长度的payload，那么必须当作消息格式错误处理。

实现注意：0xFF这个值有可能出现在一个选项的长度或选项的值中，所以简单的扫描0xFF来寻找payload标识符是不可行的。作为payload标识符的0xFF只可能出现在一个选项结束之后下一个选项有可能开始的地方。

###3.1, Option的格式

CoAP定义了许多option。消息中的每个option都有一个option编号，option值长度，和option值。
消息中的option号（TLV格式中的T）并不是直接指定option编号的。所有的option必须按实际option编号的递增排列，某一个option和上一个option之间的option编号差值为delta；每一个TLV格式的option号都是delta值（数据包中第一个option的delta即它的option编号）。同一个编号的option再次出现时，delta的值为0。

option编号由“CoAP option编号”表维护（见12.2节）。5.4讲述了本文档中定义的option的语义。

     7   6   5   4   3   2   1   0
	+---------------+---------------+
	|               |               |
	|  Option Delta | Option Length |   1 byte
	|               |               |
	+---------------+---------------+
	\                               \
	/         Option Delta          /   0-2 bytes
	\          (extended)           \
	+-------------------------------+
	\                               \
	/         Option Length         /   0-2 bytes
	\          (extended)           \
	+-------------------------------+
	\                               \
	/                               /
	\                               \
	/         Option Value          /   0 or more bytes
	\                               \
	/                               /
	\                               \
	+-------------------------------+

        图8 option格式

一个option之中的各个字段的含义如下：

*	Option Delta：4-bit无符号整型。值0-12代表option delta。其它3个值作为特殊情况保留：

*		当值为**13**：有一个8-bit无符号整型（extended）跟随在第一个字节之后，本option的实际delta是这个8-bit值加13。

	*	当值为**14**：有一个16-bit无符号整型（网络字节序）（extended）跟随在第一个字节之后，本option的实际delta是这个16-bit值加269。

	*	当值为**15**：为payload标识符而保留。如果这个字段被设置为值15，但这个字节不是payload标识符，那么必须当作消息格式错误来处理。

*	Option Length：4-bit无符号整数。值0-12代表这个option值的长度，单位是字节。其它3个值是特殊保留的：

	*	当值为**13**：有一个8-bit无符号整型跟随在第一个字节之后，本option的实际长度是这个8-bit值加13。

	*	当值为**14**：一个16-bit无符号整型（网络字节序）跟随在第一个字节之后，本option的实际长度是这个16-bit值加269。

	*	当值为**15**：保留为将来使用。如果这个字段被设置为值15，必须当作消息格式错误来处理。
	
*	Option Value：共option Length个字节。option值字段的长度和格式取决于具体的option，有可能定义变长的值。3.2节讲述了本文档所使用的option格式。其它文档中定义的option可能使用其它option值的格式。

###3.2, Option value的格式

*	Empty：长度为0。
	
*	Opaque：一个（用户自定义的）字节序列。
	
*	Uint：一个非负的整数，以网络字节序表现，由option Length字段指定其长度。

	option有可能指定字节数的范围。如果有选择的话，发送者应该用尽可能少的字节数表示这个整数，如省略开头为的0的字节。例如，数字0用空的option值来表示（0长度字节序列），数字1用一个单字节表示，MSB first（高位优先）下为0b00000001。接收端必须能够处理0开头的值。

	实现注意：在一些高受限的、模板化的实现（比如由硬件实现）下，允许发送者使用固定长度的option。

*	String：Unicode字符串，使用UTF-8[[RFC3629]](http://tools.ietf.org/pdf/rfc3629.pdf)编码，使用Net-Unicode格式[[RFC5198]](http://tools.ietf.org/pdf/rfc5198 "[RFC5198]")。

	注意，在CoAP协议中，所有使用UTF-8编码的字符串可以不需要经过标准化转换而被直接使用，或者作为用户自定义的字节序列比较，除非该Unicode字符串是从CoAP协议之外的资源中引入的。注意，所有的ASCII（不作为特殊控制字符使用）字符都是合法的UTF-8 Net-Unicode字符串。

 
##4, 消息传递
CoAP消息在端与端之间的交换是异步的。消息承载了CoAP的请求和响应，请求和响应的语义在第5章中定义。

由于CoAP运行在如UDP这种非可靠的传输协议上，因此CoAP消息也许是乱序到达的，或是重复的，甚至被丢失。出于这个原因，CoAP中实现了一个轻量级的可靠性机制，这个机制并不是试图重新实现TCP的所有特性。它有以下特性：

*	简单的停等(stop-and-wait)重传机制，对于需要应答的消息，每次的重传等待时间会指数级增长。
	
*	对于CON和NON类型的消息，都进行重复检测。

###4.1, 消息和端

一个CoAP端可能是CoAP消息的源端或者目的端。端具体的定义（即标识）由CoAP所使用的传输协议来决定。对于本文档所指定的传输层协议，端的标识取决于所使用的安全模式（参见第9章）：对于无安全的模式，端由一个IP地址和一个UDP端口号来标识。对于其它安全模式，端的标识由具体的安全模式来定义。

CoAP协议有许多不同的消息类型，由CoAP头部的Type字段标识。

消息为请求、响应还是为空，这和请求/响应模型相关，是由头部的请求/响应码字段（code段）定义的。这个字段允许的值在CoAP代码表中定义（见12.1节）。

空消息的code段被设为0.00。它的TKL字段必须设为0，且Message ID字段后必须没有数据，否则应当做消息格式错误处理。

###4.2, 可靠的消息传输

如果CoAP协议头部中T字段标识为CON类型，则说明其采用可靠传输。CON类型的消息一般携带请求或响应，除非它是想要发送空消息以引发RST。接收端接收到CON类型消息后，**必须**是以下两种情况之一：

*	通过返回一个ACK消息确认已收到。回复的ACK必须带有和CON消息相同的Message ID，并且**必须**携带有响应（附带响应格式）或者为空消息（单独响应格式）。

*	如果是因为该消息缺少上下文而无法被正确处理（例如消息为空、使用了保留的Code类别(1，6或7)，或者消息格式错误），拒绝这个消息。通过回复对应的RST消息，或者直接忽略，接收端可以拒绝CON类型的消息。回复RST消息**必须**带有和CON消息相同的Message ID，并且**必须**为空消息。参看5.2.1节和5.2.2节。

如果接收端想要拒绝一个ACK消息或者RST消息（例如ACK消息携带有请求或者有保留的code类别，RST消息不为空消息等），只需要忽略即可。一般的，ACK和RST消息的接收端**必须不**应答ACK或RST消息。

注意：发送端重传消息的间隔以指数增长，直到它收到一个ACK或者RST消息，或者达到最大重传次数。

重传由超时时间和重传计数控制。对于每一个CON类型的消息，发送端**必须**一直维护超时时间和重传计数,直到收到对应的ACK或者RST。对于一个新的CON消息，初始的超时时间被设置为介于ACK\_TIMEOUT和ACK\_TIMEOUT*ACK\_RANDOM\_FACTOR)之间（参见4.8节）的随机值（通常不是整数秒），重传计数被设置为0。当超时发生，且重传计数的值小于MAX\_RETRANSMIT，消息被重传，重传计数增加，超时时间变为原来的两倍。如果在超时发生的时候重传计数达到了MAX\_RETRANSMIT，或者收到了一个RST消息，那么就会放弃消息的传输，由应用程序来处理这个传输失败；如果在超时之前收到了ACK，那么传输就被认为成功了。

这一机制并不强制要求精准的时钟来实现上述指数回退算法。具体的说，某个端可能由于它周期性的休眠而没有赶上某一个重传时间点，但它却赶上了下一个。然而，两次重传之间的最小时间间隔是ACK\_TIMEOUT，并且整个传输和重传的过程必须在MAX\_TRANSMIT\_SPAN（见4.8.2节）之内，尽管这意味着发送者有可能会错过传输的机会。

发送CON消息的端有可能在重传计数到达MAX\_RETRANSMIT之前就放弃重传。例如，应用程序取消了这一请求，因为它已经不再需要响应；或者有其它证据表明消息已经到达，比如该请求消息导致接收端产生了单独响应，这种情况下就很明显，丢失的仅仅是请求消息的ACK而已，重传这个请求消息毫无意义。然而，响应端**必须不**能依赖请求端这种跨层的行为，它**必须**维护状态，为这个（可能重复的）请求回复ACK。如果需要的话，即使源请求端确认了CON响应（单独响应的第2步），接收端也应该回复（源请求端重传的请求）ACK。

另一个放弃重传的原因可能是收到了ICMP错误。如果希望处理ICMP错误以减轻潜在的ICMP欺骗攻击的影响，那么在实现上，**应该**仔细检查产生ICMP消息的原始数据，包括端口号和CoAP头部信息，如Message type, code, Message ID和Token；如果由于UDP提供的接口API的限制而无法检查，那么就应该忽略ICMP错误。如果遵循了第4.6节中的“实现注意”，那么正常情况下不应该发生数据包过大错误(IPv4的"fragmentation neede and DF set" [RFC0792])RFC4443]，因此应该被忽略。如果没有遵循，那么就应该进入一个路径MTU计算算法[[RFC4821]](tools.ietf.org/pdf/rfc4821)。Source Quench和Time Exceeded类型的ICMP错误应该被忽略。主机，网络，端口或协议不可达错误和参数错误有**可能**经过适当的审查后用于通知应用程序，消息发送失败。

###4.3, 没有可靠性保障的消息传输
有的消息不需要应答。尤其是周期性的重复的消息，例如对传感器的数据的重复读取，并不需要每次都成功。

在没有可靠性保障的情况下传输，可以把消息标记为NON类型，作为更加轻量级的选择。NON消息总是承载着一个不为空的请求或者响应。接收端**必须不**应答NON消息。如果缺少必要的上下文而无法正确的处理（包括消息是空的，使用了保留类别的code(1,6或7)，或者消息格式错误）那么接收端必须丢弃这个NON消息。同时服务端有**可能**会忽略该消息或者响应一个对应的RST消息。

在CoAP层，发送者没有任何办法得知NON类型的消息是否被接收端收到。发送者**可能**在MAX\_TRANSMIT\_SPAN(在第4.7节的条款所限制，特别是PROBING\_RATE，如果没有收到响应)之内发送多个副本，网络传输也有可能导致消息出现重复。为了使接收端能够只处理一次，NON消息也带有Message ID(和CON消息的Message ID共用数字池)。

总结第4.2和4.3节，四种类型的消息的使用如表1所示。“*”代表的是正常情况下不会这么使用这个组合，除非为了引起一个RST消息(也就是“CoAP ping”)。

        +----------+-----+-----+-----+-----+
        |          | CON | NON | ACK | RST |
        +----------+-----+-----+-----+-----+
        | Request  | X   | X   | -   | -   |
        | Response | X   | X   | X   | -   |
        | Empty    | *   | -   | X   | X   |
        +----------+-----+-----+-----+-----+
              表1： 消息类型的使用

###4.4, 消息之间的关联(Message Correlation)

一个ACK消息或RST消息必定和一个CON消息或NON消息关联起来。关联是通过Message ID和附加的接收端的地址来实现的。Message ID是一个16-bit的无符号整数，由CON或NON消息的发送端生成，包含在CoAP头部中。接收端发回的ACK或RST消息**必须**带有相同的Message ID。

在EXCHANGE\_LIFETIME时间之内，相同的Message ID**必须不**能重复使用(即与同一个端通信)(见第4.8.2节)。

实现注意：有许多策略可以用来生成Message ID。最简单的情况是，通过一个变量来生成Message ID，每当发送了一个CON或NON消息，不论目标地址或端口是什么，都改变这个变量。如果一个端需要处理大量的连接，那么它也可以使用多个变量，例如为每个前缀或者目标地址使用一个变量。(注意，有些接收端可能无法区分发收到的数据包是单播还是多播的，所以生成Message ID的端必须要确保这种情况下不会重复)。强烈建议这个变量的初始值是随机的，这样可以降低off-path攻击成功的可能性。

为了使ACK或RST消息与CON或NON消息匹配，ACK(或RST)消息的Message ID和源地址必须和CON(或NON)消息的Message ID和目的地址一致。

###4.5, 去除重复消息

在EXCHANGE\_LIFETIME时间之内，当ACK消息丢失或者在第一个超时时间之前没能到达原始服务端，接收端可能收到多次重复的CON消息(由Message ID和源端地址标识)。接收端**应该**对每一次收到的重复消息都回以相同的ACK或RST，但**应该**只处理一次。当CON消息传输的请求是幂等的时候见第5.1节)，或者可以以幂等的方式来处理时，这一规则可以放宽。消息去除重复规则被放宽的例子如下：

*	服务端对于幂等的请求的每一次重传都回以相同的响应（第4.2节），这样一来它就无需维护Message ID的状态，在此情况下可以放宽规则。例如，如果重复处理的过程的开销小于保留上一个响应的开销，实现中可能把GET,PUT,或DELETE请求的重传当作独立的请求来处理。

*	对于一些非幂等的请求，只要在应用层语义上这个取舍是值得的，一些资源受限的服务器也可能会放宽规则。例如，如果一个POST请求对服务端的数据状态的影响是很短暂的，那么可能重复处理请求的开销会小于保留上一次传输的相同请求处理状态的开销。

接收端可能在NON\_LIFETIME（第4.8.2节）时间内收到重复的NON消息（由Message ID和源端地址标识）。接收端应该忽略掉重复的NON消息，只处理一次。这一规则根据应用程序的语义，有可能被放宽。

###4.6, 消息大小(Message Size)

为了提高实现的质量，应该尽量使CoAP消息小到可以在一个链路层数据包中传输（见第1章）。CoAP文档本身只限制了消息大小的上限。大于IP数据包大小的CoAP消息会造成分片。一个CoAP消息**应该**尽量包含在一个IP数据包之内（即避免IP分片）并且在UDP包的payload之中。如果目的地址的MTU大小是未知的，那么应该假定IP包的MTU大小为1280字节。如果无法从头部获知消息大小，那么应该设置消息最大为1152字节，payload最大为1024字节。

实现注意：CoAP消息大小的选择适用于IPv6和目前的大部分IPv4地址。（然而，对于IPv4，很难保障绝对不发生IP分片。如果需要支持运行在受限网络上的IPv4，那么协议的实现应该使用更为保守的IPv4数据报大小，例如576字节。按照[[RFC0791]](tools.ietf.org/pdf/rfc0791)中所述，IPv4网络的MTU可以小到68字节，减去用于安全开销的字节数，可用于UDP payload的就只剩下40字节。如果要解决这个问题，也许应该设置IPv4的DF标志位，并且执行一些路径MTU探测算法[[RFC4821]](tools.ietf.org/pdf/rfc4821)。然而在使用CoAP的一般场景中，没有必要采用这些策略） 在许多受限网络中，一个重要的数据分片发生在适配层（例如6LoWPAN L2数据包最大只有127字节，还包括了各种开销在内）。这使得协议的实现应该尽可能减少数据包大小，当消息大小达到3位数的时候，应该使用块传输(block-wise transfer)。

在受限节点上，消息的大小很重要。许多实现都需要为接收消息创建缓冲区。如果一个实现由于资源过于受限而无法分配足够的缓冲区，那么对于不使用DTLS的消息，它可以使用以下策略：如果接收到一个数据报，但缓冲区太小不足以存储整个数据报，接收端通常能够判断出数据报的尾部是否被丢弃，并且能获得数据报的开头。一般来说，CoAP的头部和option部分很可能在缓冲区中。因此服务端可以正确理解这个请求，如果payload部分被截断了，可以返回一个4.13(请求数据过长，见第5.9.2.9节)的响应。当某个端发送一个幂等的请求，但接收到的响应大于它缓冲区大小，那么它可以为Block Option设置一个恰当的值，重复发送这个请求(见Bormann, C.和Z. Shelby著”Blockwise transfer in CoAP”)。

###4.7 拥塞控制
CoAP的基本拥塞控制由指数回退机制提供，见4.2节 。

为了避免拥塞，客户端（包括代理）**应该**严格限制他们同时与指定的服务器（包括代理）维持的未完成交互的数量（即NSTART值）。一个未完成的交互可以是一个仍在等待ACK的CON消息；也可以是一个在等待响应消息或者ACK的请求（这两种情况可以同时出现，做为同一个未完成的交互）。在本协议里NSTART的默认值为1.

另外，在未来拥塞控制可能会进一步得到考虑和优化，CoAP传输参数(如4.8节中定义)可以自动初始化，因此可能允许NSTART值大于1。

当EXCHANGE\_LIFETIME超时后，如果该CON请求还没有收到响应，客户端就会停止等待。客户端停止等待一个已经收到ACK的CON请求(单独响应情况)或者对一个NON请求的响应的策略还未被定义。除非有额外的拥塞控制优化，否则它向其他未响应端的平均发送速率**必须**不超过PROBING\_RATE。

注意：CoAP协议中，拥塞控制主要由客户端实现。然而，客户端可能会出现故障(或者客户端实际上就是攻击者)，例如，在第11.3节中提到的放大攻击。为了将损失（网络带宽及能耗）降到最低，对合理的应用请求，服务器**应该**对响应限速。对于行为异常的端来说限速是有且最有效的办法了。
###4.8 传输参数
信息的传输由以下参数控制

                   +-------------------+---------------+
                   | name              | default value |
                   +-------------------+---------------+
                   | ACK_TIMEOUT       | 2 seconds     |
                   | ACK_RANDOM_FACTOR | 1.5           |
                   | MAX_RETRANSMIT    | 4             |
                   | NSTART            | 1             |
                   | DEFAULT_LEISURE   | 5 seconds     |
                   | PROBING_RATE      | 1 byte/second |
                   +-------------------+---------------+
		   表2： CoAP协议参数
####4.8.1 改变参数
以上参数（包括动态调整值）一般需要在具体应用的环境中配置，但是配置方法超出本协议的讨论范围。本规范**建议**在应用环境中使用统一的参数。同样，对于配置不一致的参数值所产生的影响也超出本协议讨论范围。

如果在目前的拥塞情况下，所选择的传输参数在网络上是可以稳定运行，配置使用不同的参数值，可能会使得拥塞控制的性能受到影响。注意，ACK\_TIMEOUT小于1秒不符合[RFC5405](tools.ietf.org/pdf/rfc5405)([[RTO-CONSIDER]](www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22Retransmission+Timeout+Considerations%22)也提供了一些额外的说明)。CoAP的设计可以保证那些不能维持RTT测量的应用运行。然而，要减小ACK\_TIMEOUT或者增加NSTART，只有在能保持那个测试结果的时候安全进行。当没有一种机制来确保拥塞控制安全的时候，绝对不能减小ACK\_TIMEOUT或者增加NSTART。因此，要么尽量限制这种配置，要么等到将来的文档中定义新的标准。

ACK\_RANDOM\_FACTOR（应答随机因子）绝对不能小于1.0，且最好有一个和1.0不同的值以保护同步。

MAX\_RETRANSMIT（最大重传时间）可以自由的调整，但是如果太小的话将会减小收到CON包的概率，然而如果比这里给定的值要大的话，那些对时间有要求的参数要做更进一步的调整（参见4.8.2节）。

如果传输参数的选择导致衍生时间的增加（参见4.8.2小节），**必须**确保调整后的值对所有通信端都有效。
####4.8.2 传输参数的衍生时间
ACK\_TIMEOUT（应答超时时间）、ACK\_RANDOM\_FACTOR（应答随机因子） 和MAX\_RETRANSMIT（最大重传时间）这三个参数共同影响着重传时间，重传时间反过来也影响着这些参数需要保持的时间长度。为了能够对这些derived时间值有一个明确的参考，这里给出以下名称：

*	最大传输跨度（MAX\_TRANSMIT\_SPAN）：指的是从CON消息第一次发送到它的上一次重发之间的最大时间间隔。对默认的传输参数，它的值是(2+4+8+16)*1.5 = 45s，或者一般表示为：

	`ACK_TIMEOUT * ((2 ** MAX_RETRANSMIT) - 1) * ACK_RANDOM_FACTOR`

*	最大传输等待时间（MAX\_TRANSMIT\_WAIT）：是指从第一次传输CON消息到发送方放弃接收ACK者RST响应之间的时间间隔。默认的传输参数的值是93秒，或者表示为：

	`ACK_TIMEOUT * ((2 ** (MAX_RETRANSMIT + 1)) - 1) *ACK_RANDOM_FACTOR`

此外，我们还需要在一些网络和节点的特征上做些假设。

*	最大时延（MAX\_LATENCY）：指的是数据包从开始发送到完全接收之间的最大时间 。该常量与[[RFC0793]](tools.ietf.org/pdf/rfc0793)(协议中的MSL（最大段周期）相关，一般被设定为2分钟。注意，这并不一定比最大传输等待时间小，最大时延并不是想要描述当协议工作良好的情形，而是确保在最坏的情况下有保障。我们也可以很随意的定义最大时延为100秒。除了大量的配置与以前的TCP接近，这个值也允许Message ID存活时间定时器由8-bit数值表示（单位为秒）。在这些计算中，没有考虑传输方向的影响（假设网络是对称的）。如果不是这种情况，接下来计算将变得稍微复杂一些。

*	处理延时（PROCESSING\_DELAY）：指的是CON消息得到ACK响应的时间。我们假设节点恰好在发送端超时之前发送ACK，那么这个时间就等于ACK\_TIMEOUT。

*	MAX\_RTT：往返时间的最大值，或者是：

	`（2 * MAX_LATENCY) + PROCESSING_DELAY`

从这些值中，我们可以得到与协议操作相关的下列值：

*	交换周期(EXCHANGE\_LIFETIME)：它是指从开始发送CON消息到不再接收ACK之间的时间，即该信息在消息层交换时可以被清除。交换周期包括MAX\_TRANSMIT\_SPAN、发送过程的MAX\_LATENCY、PROCESSING\_DELAY和接收过程的MAX\_LATENCY。注意，如果最后等待周期(ACK\_TIMEOUT * (2 ** MAX\_RETRANSMIT)或MAX\_TRANSMIT和MAX\_TRANSMIT\_WAIT的差)小于MAX\_LATENCY，这里就无需考虑MAX\_TRANSMIT\_WAIT(这种情况一般不可能出现)。在这种情况下，EXCHANGE\_LIFETIME简化为：

	`MAX_TRANSMIT_SPAN + (2 * MAX_LATENCY) + PROCESSING_DELAY`

一般缺省值为247秒。

*	不需确认消息周期(NON\_LIFETIME)：它指的是从发送NON消息到该Message ID可以被复用之间的时间。如NON消息没有多次发送，那么它的值是MAX\_LATENCY或者是100秒。然而，尤其是在多播应用中，一个CoAP发送端可能发送NON消息很多次。Message ID重用超出本文档范围内。接收端希望在MAX\_TRANSMIT\_SPAN的时间内判断是否是重传包。基于这样的目的，使用缺省值145秒或使用下面的值将会更安全： 

	`MAX_TRANSMIT_SPAN + MAX_LATENCY`

对于仅想通过一个超时时间来判断Message ID是否能够重用的应用来说，使用较大的EXCHANGE\_LIFETIME更安全。

表3列举了上述一些参数的缺省值

           +-------------------+---------------+
           | name              | default value |
           +-------------------+---------------+
           | MAX_TRANSMIT_SPAN |          45 s |
           | MAX_TRANSMIT_WAIT |          93 s |
           | MAX_LATENCY       |         100 s |
           | PROCESSING_DELAY  |           2 s |
           | MAX_RTT           |         202 s |
           | EXCHANGE_LIFETIME |         247 s |
           | NON_LIFETIME      |         145 s |
           +-------------------+---------------+
		   表3 一些参数的缺省值
## 5, 请求/响应的语义
CoAP模型的操作方式和HTTP的请求与响应模型类似：一个CoAP端作为客户端发送一个或者几个CoAP请求给服务端，服务端会发送CoAP响应来回应。与HTTP不同的是，HTTP的请求与响应是在一个优先建立好连接的基础上发送的，CoAP的请求与响应是直接通过CoAP消息进行异步交换。

### 5.1, 请求
CoAP的请求包含了应用到资源上的方法，资源的识别，payload和网络媒体的类别，以及可选的元数据请求。

CoAP支持基本的GET,POST,PUT和DELETE方法，这些方法可以简单的映射到HTTP中。它们和HTTP（见[RFC2616]第9.1节）有相同的安全属性（仅检索）和幂等（多次调用有同样的效果）特性。GET的方法是安全的，因此，只能对这个资源进行检索，不能进行其他任何操作。GET,PUT和DELETE方法**必须**以幂等的方式执行。POST不支持幂等，因为它的效果是由源服务端和目标资源决定的，POST的结果是建立一个新资源或者是更新目标资源。

请求通过设置CoAP头部的字段来初始化一些信息，比如该消息是是CON还是NON的。

请求使用的方法在5.8节中有详细的描述。

### 5.2, 响应
在接收到并解析了一个请求之后，服务端会回应一个CoAP响应，这个响应是通过客户端生成的token来匹配。注意，这和CON消息要与ACK通过Message ID匹配的机制不同。

一个响应是通过CoAP头部的字段来定义为一个响应码，与HTTP状态码类似，CoAP响应码显示尝试理解并满足请求的结果，这些codes在5.9节有完整的定义。响应码的编号是在CoAP头部的字段中设定的，并保存在CoAP响应码表中（12.1.2节）。

              0
              0 1 2 3 4 5 6 7
             +-+-+-+-+-+-+-+-+
             |class|  detail |
             +-+-+-+-+-+-+-+-+
			图9 Response Code结构

上面8-bit的响应码中的高3-bits定义响应的种类。低5-bits没有任何分类作用，他们仅提供一些额外的细节（图 3-3）。

CoAP响应码格式是“c.dd”，这里”c”是一个十进制数，”dd”是两位十进制数。举个例子，”Forbidden”被定义为4.03——这是一个8-bit的值,16进制为0x83（4*0c20+3）或者十进制131（4*32+3）。

有3种响应码：

*	2-success：代表成功收到请求，理解并接收。

*	4-client Error：客户端错误，代表请求包含了错误的语法或者服务端不能满足请求。

*	5-server error：服务端错误代表服务器未能响应请求。

响应码被设计成可扩展的：在客户端或者服务端错误中，如果某个端不能识别具体响应码，这个端会将之视为一般响应码（即4.00或5.00）。然而，对于success类，如果某个端不能识别具体响应码，那么这个端只能判断这个请求成功，而不能有更多的操作。在5.9节对响应码的做了详细的描述。响应能被通过多种方式发送，在接下来的小节中有定义。

####5.2.1, 附带响应
在大多数案例中，响应直接携带在ACK中（如果这个请求是CON)。这称为附带响应。

无论响应显示是成功还是失败，响应通过ACK消息回传。实际上，响应是附带在ACK中，不需要单独发送一个响应消息。

注意：规范将是否在ACK消息附带响应的决定权留给服务端。客户端必须同时做好接收这两种的准备。从实现层面考虑，强烈建议服务端只要有可能就采用附带响应——这种方式能节省客户端和服务端的网络资源。

####5.2.2, 单独响应
不是所有的消息都能将响应附带在ACK中回传。举个例子，一个服务端可能需要一段时间(比ACK超时时间更长)来获取资源表现，因此不需要冒险让客户端反复的重传请求信息（参见4.8.2节中PROCESSING\_DELAY的讨论）。当请求是携带在NON中时，响应总是和ACK分离的（因为NON不需要ACK）。

服务端产生单独响应的时机是，服务端在获得资源表现过程中，ACK定时器超时。如果服务端提前知道不会有附带响应，服务端也可能马上发一个ACK。在这两个情况中，ACK都表示请求将马上执行。

当服务器最终获得了资源表现后，它发送这个响应。服务器希望消息不丢失，它会选择一个新的Message ID，发送CON到客户端，并需要客户端回复一个ACK（可能也会发送NON，参见5.2.3）。

当服务端选择使用单独响应，它会发送空的ACK给CON请求。只要服务端回复了空的ACK，即使客户端重传另一个同样的请求，它也不能再回复附带响应。如果收到一个重传的请求（可能是因为原有的ACK延迟了），服务端发送另一个空的ACK，所有的响应都必须发送单独响应。

如果这个服务端接着发了一个CON的单独响应，客户端回复这个响应的ACK也**必须**是空的信息（不携带请求和响应的消息）。收到ACK后，服务端在所有匹配的ACK(忽略任何响应码和payload)和RST消息中停止重传该响应。

实现注意：由于底层数据报传输可能是无序的，因此，单独响应的CON消息可能在请求的空ACK前到达客户端。为了避免重传，这个CON消息也作为ACK来处理。也要注意，虽然CoAP协议本身不做任何特殊的要求，但应用可能期望响应会在一个时间期限内到达。因为底层传输没有keep-alive机制，请求者可能要建立一个超时时间（与CoAP重传时间无关）以防服务端出问题或者不能响应。

####5.2.3, 无需确认消息NON
如果是NON请求，响应也**应该**通过NON回复。然而，端**必须**在发送CON请求时准备好接收一个NON响应（领先或者落后于一个空的ACK），在发送NON请求时准备好接收一个CON响应。

###5.3, 请求/响应的匹配
不管响应是怎么被发送的，响应和请求依靠包含在客户端的请求中的令牌（token），以及额外的相关端地址信息来匹配。

####5.3.1, 令牌（token）
token是用于匹配响应与请求的。token的值有0~8字节（注意，每个信息都携带token，即使其长度为零）。每个请求都携带由客户端生成的token，服务端在响应时必须复制（不能修改）这个token。

token用作client-local标示，用于区分并发请求（参见5.3节），也称为“request ID”。

客户端生成token时需要注意，当前使用的token对给定的源端和目的端**应该**都是独一无二的。（注意客户端在生成token时，如果要向不同的端（比如源端口号不同）中发送请求，可以使用同样的token）。当只向目的端产生一个token，或者向每个目的端发送的请求都是顺序的，且都是附带响应，token为空也是可行的。有多种策略实现。

如果客户端不使用传输层安全(TLS，见第9章）发送请求，就需要使用复杂的，随机的token来防止欺诈响应（见11.4节），起到保护功能，这也是token允许使用最多8个字节的原因。token中随机组件的实际长度取决于客户端的安全需求和欺诈响应造成的威胁程度。接入到互联网的客户端至少应该使用32位随机码，记住，没有直接连接互联网也不一定能有效防范欺诈。注意，Message ID几乎没有添加保护，因为它通常是顺序分配的，因此可能被猜测到，并通过欺诈响应绕过。客户端想要优化token长度，可能会向进一步检测正在进行的攻击等级（例如计算接收的token不匹配的消息个数）。[[RFC4086]](tools.ietf.org/pdf/rfc4086)讨论对安全的随机性要求。

端接收一个不是它生成的token，必须把这个token当做不透明的，不能假设它的内容和结构。
####5.3.2, 请求/响应匹配规则
确切的匹配响应与请求的规则如下：

1. 响应的源端必须和原始请求的目的端一致。

2. 在附带响应中，CON请求和ACK的“Message ID”必须匹配，响应和原始请求的“token”必须匹配。在单独响应中，只需响应和原始请求的“token”匹配。万一信息携带异常的响应（不是认定的端，端地址、token和客户端的期望不匹配），这个响应**必须**被拒绝（见4.2和4.3）。

注意：客户端接收到CON响应之后，可能想在回复完ACK马上清除这个消息的状态。如果这个ACK丢失，且服务端重传这个CON消息，客户端可能不会再有任何与该响应相关联的状态，会导致这个重传成为异常消息；客户端可能会发送RST信息，这样它就不会再收到更多的重传消息。这个行为是正常的，并不是一个错误（没有积极优化内存使用状态的客户端会将第二个CON认定为重发。客户端事实上期望从服务器[observe]得到更多消息，就必须在任何情况下保持状态）。

###5.4, 选项
请求和响应可能包含一个或多个option的列表。举个例子，请求消息里的URI是都在多个option中传输，在HTTP中元数据可能会携带在HTTP头部，也是作为option来提供的。

CoAP定义了一组用于请求和响应的选项。

* Content-Format
* ETag
* Location-Path
* Location-Query
* Max-Age
* Proxy-Uri
* Proxy-Scheme
* Uri-Host
* Uri-Path
* Uri-Port
* Uri-Query
* Accept
* If-Match
* If-None-Match
* Size1

这些选项的语义和他们相应的属性都在5.10节有详细定义。

并不是所有的选项都被定义可以使用所有方法和响应代码。方法和响应码的可能的选项都各自被定义在5.8和5.9节。如果一个选项没有定义方法或响应代码，，那它就禁止包含在发送内容里，并且必须被接收端当作未识别的选项。

####5.4.1, 重要选项/非重要选项Critical/Elective
选项分两个种类：重要“critical”或者非重要“elective”。这两者的不同之处是端如何处理一个不能识别的option。

* 根据接收情况，不能识别的非重要option必须忽略。
* 不能识别的非重要option出现在一个CON请求中，必须返回4.02（Bad Option）的响应。这个响应应该包含一个诊断的payload来描述这个不能识别的option（见5.5.2节）。
* 不能识别的重要option出现在一个CON响应中或者附带响应的ACK中，必须拒绝这个响应（4.2节）。
* 不能识别的“critical”option出现在一个NON消息中，必须拒绝这个消息。

注意，无论重要还是非重要，option永远不会强制(总是可选)：这些规则是为了实现停止处理它们没有理解的或没有执行的option。

重要/非重要规则不适用于代理。代理处理option基于Unsafe/Safe-to-Forward (定义于5.7节)。
####5.4.2, Proxy Unsafe or Safe-to-Forward and NoCacheKey
一个option除了被标注为重要或者不重要之外，option同样会基于代理如何处理不能识别的option来分类。为此，option可以被视为unsafe to forward（unsafe标识被设置），或者safe-to-foreword（unsafe标识被清除）。

此外，在请求中对于被标记为safe-to-forward的option，option编号表明它是否成为cache-key（见5.6节）的一部分。只要有一位NoCacheKey bits是0，它就是cache-key的一部分；如果所有的NoCacheKey bits是1，它才不是（见5.4.6节）。

注意：Cache-Key只和依赖于Unsafe/Safe-to-Forward指示，而不是将给定的option执行为请求option的代理相关。举个例子，ETag，使用请求选项作为Cache-Key的一部分实际上是非常低效的，但如果ETag没有被代理执行，这就是你所能做的最好的事，因为响应将根据请求选择而变化。一个更有用的代理，不用执行ETag请求选项，就是不使用ETag作为Cache-Key的一部分。
NoCacheKey以3-bit表示，所以八个响应码只有一个是NoCacheKey，剩下七个响应码代表其他情况。与这些分类相关的代理行为在5.7节有定义。与这些分类相关的代理在5.7节中有定义。
####5.4.3, 长度
选项值定义有一个特定长度，通常的形式是一个上界和下界。如果在请求中option的长度值超过定义的范围，这个option必须当做一个不能识别的option处理（见5.4.1节）。

####5.4.4, 默认值
Option可能有被定义一个默认的值。如果一个option的值是默认值，这个option就不应该包含在消息中，如果这个option不存在，必须假定为默认值。

当一个重要option有一个默认值时，就会以这种方式被选择，消息里的option空缺可以被两种执行合理地处理，一种是没有意识到重要option的执行，另一种是将空缺解释为存在option默认值的执行。

####5.4.5, 可重复选项
一些option的定义指定这些option是可重复的。一个消息中可能包含一个或者几个可重复的option。一个不可重复的option，在一个消息中绝对不能出现超过一次。

如果消息里的option出现的次数比定义的option多，随后出现的多余option**必须**当做无法识别的option(见5.4.1节)。

####5.4.6, 选项编号
一个option由一个option编号所定义，这个编号也能提供一些额外的语义信息，比如，奇数编号代表一个重要option，偶数编号代表非重要option。注意，这不只是一个约定，也是协议的一个功能：option是否重要，取决于这个option编号是奇数还是偶数。

更通俗点说，一个option编号由一位掩码来确定这个option是否重要，是unsafe还是safe-to-forward，还有，如果是safe-to-forward，还提供一个cache-key，如下图所示。在下文中，这位掩码被表示成为一个字节，当LSB格式时，option编号表示成无符号整数。当bit7（最低有效位）是1，option是重要（同样，如果是0的话为非重要）。当bit6是1，option是unsafe（同样，如果是0的话为safe-to-forward）。当bit6是0的时候，也就是这个option不是unsafe。当且仅当bit 3-5全都设置为1的时候它不是一个cache-key（NoCacheKey），所有其他的bit的组合，代表它确实是一个Cache-Key。这些options的分类在下面章节中有阐述。

               0   1   2   3   4   5   6   7
             +---+---+---+---+---+---+---+---+
             |           | NoCacheKey| U | C |
             +---+---+---+---+---+---+---+---+
			图10：option number mask（LSB）

一个端可以使用一段等价的C代码（如图11），来得到这个option的编号“onum”的特性。

	Critical = (onum & 1);
	UnSafe = (onum & 2);
	NoCacheKey = ((onum & 0x1e) == 0x1c);

	Figure 11: 选项编号的确定特性

Option的编号都定义在CoAP选项编号文档中（见12.2节）。
###5.5, Payload和表现
请求和响应依赖于各自的方法码或者返回码，因而可以包含payload。如果一个方法码或者返回码没有定义为包含payload，那么发送端一定不能包含payload，而且接收端必须要忽略它。

####5.5.1, 表现
请求或者响应的payload标明了成功是资源的表现（“resource representation”）或者请求动作的结果（“action result”）。它的格式由互联网媒体类型指定，内容编码由Content-Format选项决定。当缺乏这个选项时，没有假定的默认值，那么格式将由应用来决定（比如从应用的内容上）。如果没有指定的内容类型，才会尝试使用探测payload。

实现注意：在执行质量层面，强烈建议由资源表现来提供Content-Format的显示。因为这不是协议的要求，所以并不是一个强制要求，同时也很难概述出究竟在什么情况下会违反这种建议。

对于标示客户端或者服务端错误的响应，当且仅当内容格式(Content-Format)选项给出时，payload被认为是请求动作的结果的表示。当没有该option时，payload是诊断式的(见5.5.2)。

####5.5.2, 诊断式的payload
如果没有内容格式(Content-Format)的选项，响应中的payload使用简洁可读的诊断信息来指示一个客户端错误或者服务端错误，并解释错误的情况。该诊断信息一定要使用UTF-8格式编码[[RFC3629]](tools.ietf.org/pdf/rfc3629)，更确切的说是使用Net-Unicode格式[[RFC5198]](tools.ietf.org/pdf/rfc5198)。

这种消息和HTTP的状态行中的原因描述(Reason-Phrase)很类似。它不是为终端用户设计的，而是为软件工程师设计的，因为调试过程中需要在当前的上下文中用符合英语语言规范来解释它；因此，不需要提供语言标记的机制。与HTTP不同的是，如果在返回码(Response Code)外没有额外的信息，负载必须是空的。

####5.5.3, 经由选择的表现
不是所有的携带payload的响应都提供由请求寻址的资源的表现。然而，能够参考与响应相关的表示有时也是有用的，不依赖于它实际上是否封闭独立。

我们使用术语"selected representation"来引用被一个成功的响应选中的目标源的当前表示，如果这个相关的请求已经使用了GET方法，并且不包括任何有条件的请求选项。(5.10.8节)

已确定的响应选项提供关于选择表示的元数据，它可能不同于响应一些包含状态改变的方法的消息的表现。在该篇规范中定义的响应选项，只有ETag响应选项（5.10.6节）定义为关于选择表示的元数据。

####5.5.4, 内容协商
服务器可能会以多种表示格式来提供资源表示。如若没有来自客户端的更多信息，服务端会提供它偏爱的格式。

通过使用请求中的接收选项(5.10.4节)，客户端能够标示它偏爱接收的内容格式。
###5.6, 缓存
CoAP端点为了减少响应时间和网络带宽消耗，它可以缓存响应。

CoAP中缓存的目标是通过重利用先前的响应消息来应答当前的请求。在某些情况下：甚至无需网络请求，就能够重利用已经存储的响应，从而减少延时和网络回传；一种名为"freshness"的机制用于这个目标(参考5.6.1节)。甚至当有一个新请求时，通常可以重利用先前响应的payload来应答该请求，从而减少了网络带宽的消耗；一种名为"validation"的机制用于这个目标(参考5.6.2节)。

与HTTP不同，CoAP响应的缓存能力并不依赖于请求方法，而是依赖于返回码(Response Code)。在5.9节中返回码定义中列出了每种返回码代表的缓存能力。端点标示成功和无法识别的响应码必须不能被缓存。

对于已提出的请求，CoAP端点一定不能使用已存储的响应，除非：

* 已提出的请求方法和用于获取存储响应的方法相匹配
* 已提出的请求和那些用于获取存储回复的请求(包含请求URI)的所有选项相匹配，除了不需要匹配标记为NoCacheKey的任何请求选项(Section 5.4)或者能被缓存识别并且相对于缓存行为能够完全解释的选项匹配(比如在5.10.6中描述的ETag请求选项，也可以参考5.4.2)
* 已存储的回复是按照下面将要定义的更新或者成功验证。

用于匹配缓存入口的请求选项族可以全体称为“Cache-Key“。比起coap和coaps，在URI格式中，构成请求URI的选项匹配可以在URI格式下的特定规则中执行。

####5.6.1, 新鲜度模型(Freshness Model)
当缓存中的回复是“新鲜”的，不用联系原始服务端就能用于应答请求，因此提高了效率。

对起点服务器的测定新鲜度的机制通过使用Max-Age选项(5.10.5节)在未来提供一个明确的到期时间。Max-Age选项的意思是当响应的时间超过了指定的秒数后就被认定为“不新鲜”的。

Max-Age选项的默认值是60。所以，如果响应不在一个可缓存的响应中，那么在60秒后该响应就被认定是不新鲜的。如果最初的服务器希望禁用缓存，它就必须将Max-Age选项的值指定为0秒。

如果客户端有一个新鲜的已存储的响应，并且为已存储的响应生产了一个匹配的新请求，新的响应就会使得旧的响应失效。

####5.6.2, 校验模型
当端点对一个GET请求有一个或多个存储的响应，但又不能使用其中任意一个时(例如它们都不是新鲜的)，它能够使用GET请求中的ETag选项（5.10.6）给原始服务端一个选择存储的响应并且更新它的新鲜度的机会。这个过程称为验证或者重验证已经存储的响应。

当发送一个这样的请求，端点应当为每个适当的存储响应添加一个ETag选项来指定它们的entity-tag。

按照5.9.1.3中的描述，携带2.03(Valid)响应码的响应中，ETag选项中的entity-tag所标识的已存储响应，可以在完成更新后重新使用。

其它任何响应码都表明请求中的已存储响应都不适用。相反，响应应当用于应答请求并替代已存储的响应。

###5.7, 代理
代理是能够代表CoAP客户端执行请求的CoAP端。当客户端不能生成请求，或者需要减少响应时间、降低网络带宽或者功耗，因此需要cache响应时，代理相当有用。

在受限的RESTful环境中的整体架构中，代理可以实现完全不同的目的。客户端可以明确地选择代理，我们称为正向代理。代理也可以被插入来代替原始服务器，我们称为“反向代理”。从CoAP请求映射到CoAP请求(CoAP-to-CoAP)的代理或者转换不同的协议(跨协议)的代理，可以和正向代理、反向代理互相组合。在1.2中有这些术语的完整定义。

注意：这篇规范中的术语与互联网应用环境中的术语是兼容的，在各项细节中无需匹配它(甚至都与受限的RESTful环境无关)。没有太多的语义应该归属于术语的成分(例如正向，反向或者跨协议)。

HTTP代理，除了作为HTTP代理，通过提供传输层协议的代理功能来保证端对端通信的传输层安全。这篇规范中并没有在CoAP-to-CoAP的代理中定义这样的功能，因为在受限的RESTful环境中转发UDP包看起来没太多价值。可以参考10.2.7中的跨协议代理例子。

当客户端使用代理提出请求，会使用一个安全的URI方案(例如“coaps”或“https”)，只要在客户端和代理之间没有使用等效的底层安全机制，那么发往代理的请求必须使用DTLS。

####5.7.1, 代理操作
根据从客户端接收到的请求，代理通常需要一种为到目的端的请求分配可能的请求参数的方法。该方法完全由正向代理指定，但是也可以依赖于反向代理的特定配置。特别是，反向代理的客户端通常没有标示目的端的定位器，因此有必要在反向代理中有命名空间转换的格式。然而，代理操作的一些方面对于其各种形式是常见的。

如果代理没有使用缓存，那么它仅仅简单的往指定的目的端转发请求。否则，如果代理使用缓存但是没有与转化的请求相匹配的，且已存储的新鲜的响应，那么根据5.6节它需要更新缓存。代理识别请求的option，它应当知道该option是否能够当作在缓存值中查询的键值的一部分。举个例子，由于对于不同Uri路径值的请求指向不同的资源，Uri路径值通常当作Cache-Key的一部分，而token值从来都不能当作Cache-Key的而一部分。对于代理没能识别的但是在选项码中标记为Safe-to-Forward的选项，选项也标示了它是否包含在Cache-Key中(NoCacheKey没有完全设定或者完全设定)。（无法识别并且标记为Unsafe的选项就是4.02Bad Option）。

如果发往目的端的请求超时了，那么必须返回一个5.04（GateWay Timeout）响应。如果发往目的端的请求返回一个无法被代理处理的响应(比如无法识别的关键选项或者消息格式错误)，那么必须返回一个5.02（Bad Gateway）响应。否则代理向客户端返回响应。

如果响应在缓存中生成，生成的（或者隐含的）Max-Age选项一定不能超过最初由服务端设定的max-age，max-age表示在缓存中资源存活的时间。举个例子，对于每条响应可以按照下面的公式由代理计算出Max-Age选项：

	proxy-max-age = original-max-age - cache-age

举个例子，如果代理资源在20秒之前更新，并且最初的Max-Age是60秒，那么代理中该资源的max-age就是40秒。考虑到初始服务器的潜在网络延时，代理生成的响应的max-age值最好比该值偏小。

出现在代理请求里的所有选项都必须被处理。请求中无法被代理识别的Unsafe选项一定会导致代理返回一个4.02（Bad Option）响应。CoAP-to-CoAP代理必须往原始服务端转发不能识别的所有Safe-to-Forward选项。类似的，在响应中无法被CoAP-to-CoAP代理服务端识别的Unsafe选项会导致一个5.02(Bad Gateway)的响应。此外，不被识别的Safe-to-Forward选项必须被转发。

在第十章中详细讨论CoAP和HTTP的跨协议代理。

####5.7.2, 正向代理
CoAP区分原始服务端的请求和正向代理的请求。CoAP向正向代理的发出请求是普通的CON和NON请求，但是它们用不同的方式来指定请求URI：代理请求中的请求URI指定为Proxy-Uri选项中的字符串（参考5.10.2），而原始服务端中的请求分为Uri-Host，Uri-Port，Uri-Path和Uri-Query选项（参考5.10.1）。作为另一种选择，代理请求中的URI也可以由Proxy-Scheme选项和刚才提到的分开的选项组合而成。

当端点收到一个代理请求，而端点不想或者不能当作代理来处理这个请求URI，那么它必须返回一个5.05（Proxying Not Supported）的响应。如果授权(host and port)当作代理端点本身（5.10.2），那么请求必须当作一个本地的（non-proxied）请求。

一般来说，代理**必须**按照下面来解释请求：请求URI的设计定义输出的协议和它的细节(例如coap设计编码CoAP是在UDP之上的，而coaps设计编码是在DTLS之上的)。对于一个CoAP-to-CoAP的代理，初始服务端的IP地址和端口是由请求URI的授权分量决定的，请求URI可以被解码分为Uri-Host，Uri-Port，Uri-Path和Uri-Query选项。如果代理被配置为将代理请求转发到另一个代理，上面的解释方法会使其占用Proxy-Uri或Proxy-Scheme选项，导致其无法转发到原始服务端。

####5.7.3, 反向代理
反向代理不会利用Proxy-Uri或者Proxy-Scheme选项，但是需要从请求信息和配置信息中确定请求的目的端（下一跳）。例如，反向代理在通过资源侦测获知资源的存在后，反向代理能提供各种资源，好像它们就是自己的资源一样。反向代理可以自由的为识别这些资源的URIs建立命名空间。

反向代理也可以构建一个命名空间，可以让客户端更好的控制请求路径，比如，将主机标识符和端口编号嵌入到资源的URI路径。

在响应处理中，反向代理必须谨慎处理：不同资源的ETag选项值不能和客户端提供的资源混合起来。在很多情况下，ETag能够在不修改的条件下被转发。如果从反向代理提供的资源到各种初始服务器提供的资源的映射不是唯一的，反向代理需要生成一个新的ETag，来保证该选项的语义是正确的。

###5.8, 方法定义
在本小节中，每个方法及其行为都有定义。带有无法识别或者不支持的方法码的请求**必须**生成一个4.05(Method Not Allowed)的附带响应。

####5.8.1, GET
GET方法根据请求URI定位资源，从相符合的信息中获取对应的表现。如果请求包含Accept选项，就表明了首选的响应内容格式。如果请求包含ETag选项，GET方法要求验证ETag并且只有当验证失败的时候才会传输表现。当验证成功，响应中应当包含2.05（Content）或者2.03（Valid）的响应码。

GET方法是安全而且幂等的。

####5.8.2, POST
POST方法要求处理包含在请求中的表现。POST方法执行的实际功能由原始服务端决定，并依赖于目标资源。它通常的结果是创建新资源或者更新目标资源。

如果服务端响应请求，创建了资源，那么返回的响应码为2.01（Created），并应当在一系列Location-Path和/或Location-Query选项（5.10.7）中包含新资源的URI。如果POST方法成功但不是由服务端创建新资源引起的，那么响应中应当含有2.04（已修改）的响应码。如果POST方法成功并且是由删除目标资源引起的，那么响应中应当包含2.02（已删除）的响应码。

POST方法既不安全也不幂等。

####5.8.3, PUT
PUT方法要求更新或创建由请求URI定位的资源。表现的格式由媒体类型和Content-Format选项中的内容编码制定。

如果请求URI中的资源已存在，那么封闭表现应当看做是该资源修改后的版本，并且应当返回一个2.04（Changed）的响应码。如果没有对应的资源，那么服务端**可能**根据URI创建一个新的资源，返回一个2.01（Created）的响应码。如果既不能创建资源，又不能修改资源，那么**应当**发送一个恰当的错误响应码。

在If-Match（5.10.8.1）或If-None-Match（5.10.8.2）中包含更多对于PUT方法的限制规定。

PUT方法不安全但是幂等的。

####5.8.4, DELETE
DELETE方法要求删除由请求URI定位的资源。如果成功或者该资源不存在，**必须**返回2.02（已删除）的响应码。

DELETE方法不安全但是幂等的。

###5.9, 返回码的定义
在下面将要说明的返回码中，包括了所有请求可能导致的响应。同时，某些地方会说明该返回码对应的HTTP[[RFC2616]](tools.ietf.org/pdf/rfc2162)中的返回码，但这并不意味着会修改第10章中CoAP和HTTP的映射。

####5.9.1, 成功 2.xx
这类返回码表明客户端的请求被成功的接收、理解并接受。

#####5.9.1.1, 2.01 Created
类似HTTP的返回码201（“Created”），但该返回码仅用于对POST和PUT请求的响应。响应包中如果同时带有Payload，则表明了服务端处理的结果。

如果响应包中包含一个或多个Location-Path 与/或 Location-Query的选项，这些选项的值说明这个被创建资源的路径。否则，这个资源就在请求的URI下创建。一个缓存端如果收到这个响应必须将所有这个被创建资源的响应缓存标记为未刷新。

这种响应不能被缓存。

#####5.9.1.2, 2.02 Deleted
这个响应码和HTTP的响应码204（“No Content”）类似，但仅仅用于响应那些导致该资源无效的请求，如DELETE，或者某些情况下的POST。响应包中如果同时带有Payload，表明了服务端处理的结果。

这个响应不能被缓存，一个缓存端必须将所有为这个被删除资源的响应缓存标记为未刷新。

#####5.9.1.3, 2.03 Valid
这个响应码和HTTP的响应码304（“Not Modified”）相关，但仅用于当携带了ETag选项时，说明（请求）中的entity tag是合法的。相应的，响应也**必须**携带ETag选项且**必须不**能包含payload。

如果一个缓存端能够认出并且处理携带ETag option的响应报文，当它收到2.03响应时，它**必须**将其缓存的响应中的Max-Age option的值修改为和该响应的值一致（可能为明确的值或者是一个默认值，参见5.6.2节）。对于响应中每个转发安全选项，所有缓存的响应中的对应选项中的值应该更新为该响应的值。非安全选项可能会触发类似的选项自定义的特有的操作。

#####5.9.1.4, 2.04 Changed
这个响应码类似HTTP的响应码204（“No Content”），但仅用于POST和PUT请求的响应。如果有的话，Payload和响应一起返回，携带该操作的结果。

这个响应是不能被缓存的。因此，一个缓存端**必须**将针对这个被改变资源的缓存响应标记为未刷新。

#####5.9.1.5, 2.05 Content
这个响应码类似HTTP的响应码200（“OK”），但仅用于GET请求的响应。

Payload和响应一起返回，携带目标资源的内容。

这个响应是可以被缓存的，缓存端能够使用Max-Age选项来决定刷新时间（参见5.6.1节），如果有ETag选项，也可以将其用于数据确认（是否有更新）的检查。

####5.9.2 客户端错误 4.xx
这个响应码集合里包含了客户端一些可能出错的情况。这些响应码适用于所有请求方法。

服务端在如5.5.2节的情况下，应该返回一个包含诊断信息（diagnostic）的payload。

这个集合里的响应是可以被缓存的，缓存端能够使用Max-Age选项来决定刷新时间（参见5.6.1节），但不能用于确认检查。

#####5.9.2.1, 4.00 Bad Request
这个响应码类似HTTP的响应码400（“Bad Request”）。

#####5.9.2.2, 4.01 Unauthorized
客户端并未得到执行该操作的授权。客户端不应该重复发送这个请求，除非改变了自己的授权状态。当然，有一些特殊的机制在这种情况下能被使用（超出了本文档的范围），参见第9章。

#####5.9.2.3, 4.02 Bad Option
这个请求里面的一个或者更多的选项不能被服务端理解，或者有错误。客户端不应该重复发送这个请求，直到修改那些选项。

#####5.9.2.4, 4.03 Forbidden
这个响应码类似HTTP的响应码403（“Forbidden”）。

#####5.9.2.5, 4.04 Not Found
这个响应码类似HTTP的响应码404（“Not Found”）。

#####5.9.2.6, 4.05 Method Not Allowed
这个响应码类似HTTP的响应码405（“Method Not Allowed”），但并没有类似的Allow头部。

#####5.9.2.7, 4.06 Not Acceptable
这个响应码类似HTTP的响应码406（“Not Acceptable”），但没有响应实体。

#####5.9.2.8, 4.12 Precondition Failed
这个响应码类似HTTP的响应码412（“Precondition Failed”）。

#####5.9.2.9, 4.13 Request Entity Too Large
这个响应码类似HTTP的响应码413（“Request Entity Too Large”）。

除非服务端无法提供其最大接收的数据大小，否则应该提供一个携带Size1选项（参见5.10.9章）的响应。

#####5.9.2.10, 4.15 Unsupported Content-Format
这个响应码类似HTTP的响应码415（“Unsupported Media Type”）。

####5.9.3, 服务端错误 5.xx
这个响应码集合里包含的异常情况为：服务端出错或者无法处理这个请求。这些响应码适用于所有请求方法。

服务端在如5.5.2节的情况下，应该返回一个包含诊断信息（diagnostic）的payload。

这个集合里的响应是可以被缓存的，缓存端能够使用Max-Age选项来决定刷新时间（参见5.6.1节），但不能用于确认检查。

#####5.9.3.1, 5.00 Internal Server Error
这个响应码类似HTTP的响应码500（“Internal Server Error”）。

#####5.9.3.2, 5.01 Not Implemented
这个响应码类似HTTP的响应码501（“Not Implemented”）。

#####5.9.3.3, 5.02 Bad Gateway
这个响应码类似HTTP的响应码502（“Bad Gateway”）。

#####5.9.3.4, 5.03 Service Unavailable
这个响应码类似HTTP的响应码503（“Service Unavailable”），但是用Max-Age选项取代了HTTP的“Retry-After”头部，用来表明下次重试需要等待多少秒。

#####5.9.3.5, 5.04 Gateway Timeout
这个响应码类似HTTP的响应码504（“Gateway Timeout”）。

#####5.9.3.6, 5.05 Proxying Not Supported
请求中包含Proxy-Uri选项或者使用Proxy-Scheme（参见5.10.2节），但是服务端无法（或者不愿意）为其指定的URI做正向代理。

###5.10, Option的定义
CoAP的那些选项在表5-1中总结，并且在后面的子章节中描述。

在表中，C，U和N这几列分别代表临界（Critical），不安全（UnSafe）和不缓存（NoCacheKey）。由于NoCacheKey仅仅用于安全转发（Safe-to-Forward）选项（没有标记为Unsafe），这一列被填满了横杠。

	+-----+---+---+---+---+----------------+--------+--------+----------+
	| No. | C | U | N | R |		 Name 	   | Format | Length |  Default |
	+-----+---+---+---+---+----------------+--------+--------+----------+
	|   1 | x |   |   | x | If-Match       | opaque | 0-8    | (none)   |
	|   3 | x | x | - |   | Uri-Host       | string | 1-255  | (see     |
	|     |   |   |   |   |                |        |        | below)   |
	|   4 |   |   |   | x | ETag           | opaque | 1-8    | (none)   |
	|   5 | x |   |   |   | If-None-Match  | empty  | 0      | (none)   |
	|   7 | x | x | - |   | Uri-Port       | uint   | 0-2    | (see     |
	|     |   |   |   |   |                |        |        | below)   |
	|   8 |   |   |   | x | Location-Path  | string | 0-255  | (none)   |
	|  11 | x | x | - | x | Uri-Path       | string | 0-255  | (none)   |
	|  12 |   |   |   |   | Content-Format | uint   | 0-2    | (none)   |
	|  14 |   | x | - |   | Max-Age        | uint   | 0-4    | 60       |
	|  15 | x | x | - | x | Uri-Query      | string | 0-255  | (none)   |
	|  17 | x |   |   |   | Accept         | uint   | 0-2    | (none)   |
	|  20 |   |   |   | x | Location-Query | string | 0-255  | (none)   |
	|  35 | x | x | - |   | Proxy-Uri      | string | 1-1034 | (none)   |
	|  39 | x | x | - |   | Proxy-Scheme   | string | 1-255  | (none)   |
	|  60 |   |   | x |   | Size1          | uint   | 0-4    | (none)   |
	+-----+---+---+---+---+----------------+--------+--------+----------+
	C=Critical, U=Unsafe, N=NoCacheKey, R=Repeatable
	表4 选项表

####5.10.1, Uri-Host，Uri-Port，Uri-Path，Uri-Query
Uri-Host，Uri-Port，Uri-Path，Uri-Query选项都用来定位一个向原始服务端请求的目标资源。选项将请求URI的不同组件进行编码，在这些选项的value值中，看不到百分号编码（也称URL编码），且完整的URI能够在任何有关的端被重建。CoAP URI的语义在第六章定义。

将URI解析成选项的步骤定义在6.4节。这些步骤是由请求中的0个或者多个Uri-Host，Uri-Port，Uri-Path，Uri-Query选项决定，每个选项包含以下信息：
* Uri-Host选项定义了被请求资源的网络主机；
* Uri-Port选项定义了资源在传输层的端口号；
* 每个Uri-Path选项定义了一段资源的绝对路径；
* 每个Uri-Query选项定义了一个资源的参数。

注意：Fragments（[[RFC3986]](tools.ietf.org/pdf/rfc3986)，见3.5节）并不是URI请求的一部分，因此在CoAP请求中不会被传输。

Uri-Host选项的默认值是请求消息的目的IP地址。同样地，Uri-Host选项的默认值即UDP的端口号。Uri-Host和Uri-Port选项的默认值对于大部分服务端来说已经足够了。当一个端有多个虚拟服务端时才会使用明确的Uri-Host和Uri-Port选项。

Uri-Path和Uri-Query选项能够被任何字符顺序编码。不会采用百分号编码。Uri-Path选项的值必须不可以是“.”或者“..”（因此URI请求必须在将填充选项前将它们解析替换掉）。

例子可以在附录B找到。

####5.10.2, Proxy-Uri和Proxy-Scheme
Proxy-Uri选项被用于生成一个向正向代理（5.7节）发送的请求。用来请求正向代理将该请求转发给服务端或者从合法的缓存中返回一个响应。

该选项的值是一个绝对URI（[[RFC3986]](tools.ietf.org/pdf/rfc3986)，4.3节）。

注意，正向代理**可能**将该请求转发给另一个代理，或者直接给服务端，由absolute-URI决定。为了避免请求循环，代理必须能够识别所有它面对的服务端名字，包括任何别名，局部变化，以及IP地址。

一个Proxy-Uri选项优先于任何Uri-Host、Uri-Port、Uri-Path或者Uri-Query选项（它们每一个都**必须不**能出现在一个包含Proxy-Uri选项的请求中）。

作为一个简化一些代理客户端的特例，绝对URI可以从Uri-\*选项中构建。当Proxy-Scheme选项存在，绝对URI能够被构造如下：一个CoAP的URI按照6.5节的定义被构建。在所得的URI中，初始的scheme的冒号之后，会被Proxy-Scheme选项的内容替换。注意，这只适用于在所需的URI组件中，除了scheme组件，其他要素实际上可以使用Uri-\*选项表示的情况。例如，通过一个userinfo组件来认证URI的话，只能使用Proxy-Uri组件。

####5.10.3, Content-Format
Content-Format选项即消息的payload段。Content-Format的不同格式通过在12.3节中的CoAP Content-Format表中定义，通过数字来索引。该选项不存在默认值，即任何无该选项的payload都是未定义的（见5.5节）。

####5.10.4, Accept
CoAP的Accept选项用于表明哪些Content-Format能够被客户端接受。它的表示格式同样也是在12.3节中的CoAP Content-Format表中定义。如果没有Accept选项，表明客户端可以接收所有格式（也即该选项没有默认值）。客户端接受服务端返回它指定的格式。如果服务端无法提供客户端指定的格式，服务端必须返回一个4.06“Not Acceptable”，除非另外的错误码比这个返回码优先。

####5.10.5, Max-Age
Max-Age选项定义了一个响应在它被标记为未刷新前，最多能缓存的时间（见5.6.1）。

该选项的值是一个整型的秒数，从0到2**32-1（大约136.1年）。如响应中没有定义这个选项，它的默认值是60秒。

这个值是传输时开始计时的，那些对Max-Age时间要求严格的服务器必须在每次重传前更新这个值（见5.7.1）。

####5.10.6, ETag
实体标识作为本地资源标识符，用来区分该资源是否已经随着时间推移而变化了。它由提供资源的服务端生成，可能通过版本、checksum、哈希或者时间等方式来生成。一个收到实体标识的端**必须**将该标识视为不透明的且不能假定它的内容或结构。生成实体标识的端被提倡使用尽量压缩的表达，因为客户端和中间人可能保存多个ETag值。

#####5.10.6.1, 作为一个响应选项的ETag
响应中的ETag选项提供了它的当前值（例如，当一个请求被处理后），作为代表标签（“tagged representation”）。如果没有Location-* 选项存在，代表标签就是目标资源的选定表现(5.5.3节)。如果一个或者多个Location-\*选项存在，且因此一个URI地址被指明，代表标签表示客户端需要通过给定的URI地址重新获取资源。

一个ETag选项能够包含在任何带有代表标签的响应中（当然，如果在4.04或者4.00回复中，没什么意义）。ETag选项**必须不**能在一次响应中包含多次。

ETag选项没有默认值，如果它不存在响应中，服务端就没有代表标签的实体标识。

#####5.10.6.2, 作为请求选项的ETag
在GET请求中，一个端如果已经从资源中获取一个或者多个表现，且从响应获得了它们的ETag，就能够为一个或者多个这些已保存的响应指定ETag选项。

服务器可以发出2.03有效响应(5.9.1.3节)代替2.05内容响应，如果给定的etags中的一个当前表现为实体标记，即是有效的；然后2.03有效响应在响应选项里回应这个特定的ETag。

事实上，客户端能够确定目前所存储的表现是不是最新的（见5.6.2节），而不需要重新将他们传输。

ETag选项可能在一个请求中发生0次，1次或者多次。

####5.10.7, Location-Path和Location-Query
Location-Path和Location-Query选项定义由一个绝对路径、一个请求字符串，或者二者一起组成的相对URI。

这些选项的组合包含在2.01（Created）响应中，来定位这个被创建资源的位置，而这个响应是由POST请求（5.8.2节）引起的。这个地址是由请求URI分解得出。

如果响应携带一个或者多个Location-Path和/或Location-Query选项，该响应通过了一个解释这些选项的缓存，且其中的某些响应缓存隐含了这个URI，这些响应缓存必须被标记为未刷新。

每个Location-Path选项对应该资源绝对路径的一个段，每个Location-Query选项对应该资源的一个参数。Location-Path和Location-Query选项能够包含任何字符顺序。不执行百分号编码。Location-Path选项的值必须不能是“.”或“..”。

从选项中构造一个URI地址可以参考6.5节，跳过前5步，且该结果是一个在请求URI基础上的相对URI引用。注意一个通过这种方式构造的相对URI引用经常会包含一个绝对路径，例如，不携带Location-Path但是提供Location-Query意味着在这个URI中从“/”开始。

用来计算相对URI引用的选项统一被称为Location-\*。不仅是Location-Path和Location-Query，更多的Location-\*选项可能在未来被定义，且已经在option的数字标记中替它们保留了128,132,136和140。如果这些这些保留的选项编号出现在Location-Path和/或Location-Query之外且不被支持，必须返回4.02（Bad Option）。

####5.10.8, 条件请求选项
条件请求选项允许客户端通知服务端，当这些在选项中包含的条件被满足时才执行请求。

对于每个条件请求选项，如果给定的条件没有满足，服务端必须不能执行它所请求的方法，而必须返回4.12（Precondition Failed）。

如果条件被满足，服务端执行它请求的方法，和条件请求选项不存在时相同。

如果一个请求可能没有条件请求选项，收到除了2.xx或者4.xx的响应码，那么任何条件请求选项可能被忽略。

#####5.10.8.1, If-Match
If-Match选项可能用来为当前实体或者为一个或多个目标资源的表现的ETag值生成一个条件请求。If-Match在资源更新的请求上很有用，比如PUT请求，用于保护多个客户端在同一资源下进行类似操作时意外覆盖（比如“lost update”问题）。

If-Match选项的值是一个ETag或者是一个空白字符串。一个带有ETa的If-Match选项需要和对应表现的ETag完全相同。值为空的If-Match选项和所有存在的表现匹配（如，把目标资源任何当前表现的实体作为前置）。

If-Match选项可能多次出现。如果任意一个条件匹配，那么这个条件成立。

如果存在一个或多个If-Match选项，但没有一个选项匹配，那么这个条件不成立。

#####5.10.8.2, If-None-Match
If-None-Match选项可能被用于当目标资源不存在时，生成一个条件请求。If-None-Match对于创建请求，比如PUT请求来说很有用，能够保护多个客户端在同一资源下进行类似操作时意外覆盖。If-None-Match选项没有value值。

如果目标资源存在，这个条件不成立。

注意，将If-Match和If-None-Match选项放在一个请求中不太好，因为这会导致条件永不成立。

####5.10.9, Size1选项
Size1选项提供在一个请求中资源表现的长度信息。选项的值是一个整型，表示字节数。它主要用于块传输[BLOCK]。在目前标准中，它用于响应码码4.13（参见5.9.2.9），定义服务端能够处理的请求实体的最大长度。


##6, CoAP URI
CoAP中使用“coap”和“coaps”的URI scheme来标识CoAP资源和提供资源定位。CoAP资源由潜在的在某个UDP端口监听CoAP请求（“coap”）或DTLS加密的CoAP请求（“coaps”）的CoAP源服务器组织和分层。CoAP服务器是通过通用语法中的authority组件，即host组件（即IP地址或域名）和一个可选的UDP端口号来区分的。URI中剩余部分则标识了一个能够被CoAP协议中定义的方法操作的资源。“coap”和“coaps”的URI可以分别和“http”以及“https”的URI做类比。

“coap”和“coaps” URI scheme的语法在本章被定义，采用ABNF格式（Augmented-Bacus-Naur Form）[[RFC5234]](http://tools.ietf.org/pdf/rfc5234)。关于“host”、“port”、“path-abempty”、“query”、“segment”、“IP-literal”、“IPvaddress”和“reg-name”的定义请参考[[RFC3986]](http://tools.ietf.org/pdf/rfc3986)。

实现注意：不幸的是，到目前为止URI格式已经非常复杂。建议开发者们仔细查看[[RFC3986]](http://tools.ietf.org/pdf/rfc3986)。例如，IPv6地址上的ABNF就比预期的更复杂。同样的，开发者们需要小心处理URI的百分比解码或百分比编码的处理，在从一个URI和它的解码组件之间只执行一次。百分号编码对数据透明相当重要，但是处理不好可能会导致未定义的结果，例如在path组件中的斜线。

###6.1, Coap URI scheme

	coap-URI = “coap:” “//” host [ “:” port ] path-abempty [ “?” query ]

如果host组件提供的是一个ip如ipv4地址（例如192.168.1.1），那么CoAP服务器可以通过该ip地址访问。如果host是一个域名，由于域名是一个间接的标识，因此端需要使用域名解析服务如DNS，来发现host的真正地址。host必须不能是空；如果收到一个authority或者host为空的URI，那么**必须**认为这是一个非法的URI。port组件则代表CoAP服务端可以在UDP的哪个端口被访问。如果为空或者未提供，则使用默认的5683端口。

path则在一个host和port范围内定义了资源。它由一系列被“/”（U+002F）分隔开的路径段组成。

请求用来对资源进行进一步优化。它们由“&”（U+0026）分隔。一个参数经常由“key=value”格式组成。

“coap”URI还支持路径前缀“/.well-known”，它在[[RFC5785]](http://tools.ietf.org/pdf/rfc5785.pdf)中定义为host命名空间里的“well-known locations”。它允许对一个host的policy或其他信息（“site-wide metadata”）的发现，例如hosted资源（第7章）。

建议应用开发者们采用尽量简短而清晰的URI。由于CoAP经常使受到带宽和功耗的限制，所以应该优先考虑简短，但又不忽略清晰性。

###6.2, Coaps URI scheme
	coaps-URI = “coaps:” “//” host [ “:” port] path-abempty [ “?” query]

在上一节所列举的“coap”的要求也适用于“coaps”，不同的在于，“coaps”默认端口为5684，且UDP数据报必须通过DTLS（见9.1节）加密。

“coaps”请求的缓存回复在第11.2节讨论。

在“coaps”下获取的有效资源和“coap”下不是相同的，即使“coap”和“coaps”可能采用相同的host和端口，它们命名空间相互独立，且可视为独立的原始服务器。

###6.3, 标准化和比较规则
由于“coap”和“coaps”符合URI通用语法，它们的URI的标准化和比较规则采用上述默认描述，符合在[[RFC3986]](http://tools.ietf.org/pdf/rfc3986#section-6)中的算法，参见第6章。

如果端口和默认的端口一致，通常可以省略端口子组件。类似的，path组件为空等同于绝对路径“/”，因此通常做法是将path的值替换为“/”。scheme和host对大小写不敏感（即EXaMpLE等价于example），但通常采用小写；ip字段则采用[[RFC5952]](http://tools.ietf.org/pdf/rfc5952)的方式；其他所有组件则是大小写敏感的。除了保留的字符以外，都等价于其对应的百分号编码（参见[[RFC3986]](http://tools.ietf.org/pdf/rfc3986#section-2.1)，2.1节）；通常做法是不对它们编码。

举个例子，下面的几个CoAP消息的URI是等价的：

	coap://example.com:5683/~sensors/temp.xml
	coap://EXAMPLE.com/%7Esensors/temp.xml
	coap://EXAMPLE.com/%7esensors/temp.xml

###6.4, 将URI解码为选项
将请求的URI解析成option的步骤如下所述。经过这些步骤后，要么生成包含0个或多个Uri-Host、Uri-Port、Uri-Path和Uri-Query选项的请求，要么会失败。

1. 如果URI不是一个绝对URI（[[RFC3986]](http://tools.ietf.org/pdf/rfc3986)），那么解析失败。
2. 采用[[RFC3986]](http://tools.ietf.org/pdf/rfc3986)中的解决方案来处理URL。在这一步，即使在第5、8、9步后会被解码成UTF-8[[RFC3629]](http://tools.ietf.org/pdf/rfc3629)，URL是ASCII编码[[RFC0020]](http://tools.ietf.org/pdf/rfc0020)。

	注意：不用关心这个URL是和谁相关的，因为我们知道此时它是一个绝对URL。
3. 如果被转化成为小写ASCII字符后的URL不含有值为“coap”或者“coaps”的scheme组件，那么解析失败。
4. 如果URL有一个fragment组件，那么解析失败。
5. 如果URL中的host组件不是以ip字符串格式组成的请求端目的ip地址，那么要包含一个Uri-Host选项，并且让选项的值和host组件的值相同，转化为ASCII小写字母，然后将所有百分号编码转化为为对应的字符。

	注意：通常来说请求的目的ip地址是从host获取，它保证了Uri-Host选项仅用于host组件，格式为reg-name。
6. 如果URL有port组件，那么将port的值解析成十进制整型，否则，port采用默认值。
7. 如果port的值和请求的目的UDP端口不一致，增加Uri-Port选项并将其值置为port的值。
8. 如果URL中的path组件为空或者只有一个“/”（U+002F），则进行下一步；否则，针对path组件中的每个段，都需要包含一个Uri-Path选项，且将选项的值（将百分号编码转换为对应的字符后）置为这个段的值（不含分隔符）。
9. 如果URL有query组件，那么，针对每个query组件中的参数，都需要包含一个Uri-Query选项，并且让选项的值（将百分号编码转换为对应的字符后）为该参数的值（不包含“？”和“&”）。

	注意，这些规则可以完全解析任何百分比编码。
###6.5， 将选项编码成URI
将请求选项转化为URI的步骤如下。经过这些步骤后，要么会生成一个URI，要么失败。在这些步骤中，百分号编码一个字符意味着将每个UTF8编码字符转化成由一个“%”开头的、两字节的十六进制数，其中A-F是大写的（如2.1节中采用的[[RFC3986]](http://tools.ietf.org/pdf/rfc3986)定义，为了减要么少复杂度，CoAP URI中，百分号编码中的十六进制数必须为大写）。unreserved和sub-delims的定义请参考[[RFC3986]](http://tools.ietf.org/pdf/rfc3986)。

1. 如果请求用DTLS加密，则URL开头用“coaps://”，否则用“coap://”。
2. 如果请求包含了Uri-Host选项，则将URL中的host的值置为该选项的值，所有非ASCII的字符转化成百分号编码。如果host不是一个合法的域名格式或者ip格式，将导致失败。如果请求没有Uri-Host选项，将host的值置为请求的目的ip地址（V4或V6格式）。
3. 添加host到URL。
4. 如果请求中有Uri-Port选项，则将port组件的值置为该选项的值。否则采用请求的目的端UDP端口。
5. 如果port不是该scheme默认的端口号，则采用“：”+port值的方式加载URL后面。
6. 将resource name清空。对请求中的每个Uri-Path选项，采用“/”+选项的值跟随在resource name后面。在此之前，需要先将不在unreserved集、sub-delims集、不为“：”、“@”的字符转化为百分号编码。
7. 如果resource name为空，将它设置为“/”。
8. 对请求中的每个Uri-Query选项，采用“？”（第一个选项）或“&”（后续选项）+选项值的形式编码到resource name中（同样的，在此之前，需要先将不在unreserved集、sub-delims集、不为“：”、“@”、“/”、“？”的字符转化为百分号编码）。
9. 将resource name添加到URL中。
10. 返回URL。

注意：这些步骤旨在以标准形式构建一个URI（参见6.3节）。
